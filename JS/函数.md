# 函数

## 目录

[构造函数，new 时发生了什么](#jump1)

[调用函数有哪几种方式](#jump2)

[eval 是做什么的](#jump3)

[节流与防抖](#jump4)

[](#jump)

[](#jump)

---

<span id="jump1"></span>

## 执行构造函数，new时发生了什么

### 发生了什么

当执行```let o = new Foo();```时，实际上执行了如下操作：

1. Create a new object obj

```javascript
let o = {};
let [Foo, ...args] = [...arguments];  // 第一个参数是构造函数
```

2. Prototype chain connection: point the ```proto``` of this empty object to the ```prototype``` of the function 

```javascript
o.__proto__ = Foo.prototype;
```

3. Replace the ```this``` pointer of the function with o, and add the properties and methods of the constructor to this new empty object

```javascript
let result = Foo.apply(o, args);
```

4. If the result returned by the constructor is an object, return this object; otherwise return the created new object

```javascript
if(result && (typeof result == "object" || typeof result == "function")){
  // 如果构造函数返回的结果是一个对象，就返回这个对象
  return result;
}
// 如果构造函数返回的不是一个对象，就返回创建的新对象。
return o;
```

### 类似的问题：如何实现一个 new

```javascript
function _new(func, ...args) {
  let obj = Object.create(func.prototype); // 原型
  let res = func.apply(obj, args); // 初始化对象属性
  return res instanceof Object ? res : obj; // 返回值
}
```

---

<span id="jump2"></span>

## 调用函数有哪几种方式

- 方法调用模式 Foo.foo(arg1, arg2);

- 函数调用模式 foo(arg1, arg2);

- 构造器调用模式 (new Foo())(arg1, arg2);

- call/apply 调用模式 Foo.foo.call(that, arg1, arg2);

- bind 调用模式 Foo.foo.bind(that)(arg1, arg2)();

---

<span id="jump3"></span>

## eval 是做什么的

它的功能是把对应的字符串解析成 JS 代码并运行

应该避免使用 eval，不安全，非常耗性能（2次，一次解析成 js 语句，一次执行）

---

<span id="jump4"></span>

## 节流与防抖

函数防抖： 在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时

函数节流： 规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效

### 函数防抖

```javascript
function debounce(fn, wait) {
  var timer = null;

  return function() {
    var context = this,
      args = arguments;

    // 如果此时存在定时器的话，则取消之前的定时器重新记时
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }

    // 设置定时器，使事件间隔指定事件后执行
    timer = setTimeout(() => {
      fn.apply(context, args);
    }, wait);
  };
}
```

### 函数节流

```javascript
function throttle(fn, delay) {
  var preTime = Date.now();

  return function() {
    var context = this,
      args = arguments,
      nowTime = Date.now();

    // 如果两次时间间隔超过了指定时间，则执行函数
    if (nowTime - preTime >= delay) {
      preTime = Date.now();
      fn.apply(context, args);
    }
  };
}
```
