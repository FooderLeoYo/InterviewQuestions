# 选择器

## 目录

[伪元素和伪类的区别和作用](#jump1)

[伪元素双冒号和单冒号写法有什么区别](#jump2)

[css的权重](#jump3)

[CSS选择符有哪些？](#jump4)

[浏览器是怎样解析 CSS 选择器的?](#jump5)

[](#jump)

[](#jump)

[](#jump)

[](#jump)

[](#jump)

[](#jump)

---

<span id="jump1"></span>

## 伪元素和伪类的区别和作用

### 伪类

伪类用于当已有的元素处于某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的元素时，我们可以通过:hover来描述这个元素的状态

常用伪类包括：

```css
:active
:focus
:hover
:link
:nth-child()
:nth-of-type()
:visited
```

[完整的伪类索引](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-classes)

### 伪元素

伪元素用于创建一些不在文档树中的元素，并为其添加样式。它们允许我们为元素的某些部分设置样式

比如说，我们可以通过::before来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中

常用伪元素包括：

```css
:first-letter
:first-line
:before
:after
```

[完整的伪元素索引](https://developer.mozilla.org/zh-cn/docs/web/css/pseudo-elements)

---

<span id="jump2"></span>

## 伪元素双冒号和单冒号写法有什么区别

伪元素在 CSS1 中已存在，当时语法是用 : 表示

后来在 CSS3 中修订，伪元素用 :: 表示，以此区分伪元素和伪类

由于低版本 IE 对双冒号不兼容，开发者为了兼容性各浏览器，继续使使用 :

综上所述：:: 是 CSS3 中写伪元素的新语法； : 是 CSS1 中存在的、兼容 IE 的老语法

---

<span id="jump3"></span>

## css的权重

### 权重的叠加

#### 4类选择器的优先级权重等级

- 行内样式选择符：x,0,0,0

- ID选择符：0,x,0,0

- class选择符/属性选择符/伪类选择符：0,0,x,0

- 元素和伪元素选择符：0,0,0,x

#### 计算规则

- 每个等级的叠加为该等级选择器出现的次数相加

- 等级判断从左向右，如果某一位数值相同，则判断下一位数值

- 权重虽然会叠加,但是永远不会有进位，如：10个0,0,0,1加起来是0,0,0,10,也不如一个0,0,1,0权重大

- 通配符选择器的权重值为：0,0,0,0

#### 例子

继承关系为father-->ul-->li，计算li的权重:

```css
#father { /* 权重是0，!important虽然是最高级权重但是是father的权重，可以理解为父亲再高跟儿子也没关系 */
    color:green !important
}
li { /* li 权重是 0,0,0,1 */
    color: red;
}
ul li { /* ul li 权重是  0,0,0,1 + 0,0,0,1  =  0,0,0,2 */
    color: green;
}
.nav li { /* .nav li  权重是  0,0,1,0  +  0,0,0,1  =  0,0,1,1 */
    color: pink;
}
```

结果为：权重从上往下为从小到大

### 优先级的比较规则

- 权重值越大的声明优先级越高

- !important优先级最高

- 继承样式优先级最低，通配符样式优先级都高于它

- 如果两个权重不同的选择器作用在同一元素上，权重值高的 css 规则生效

- 如果两个相同权重的选择器作用在同一元素上，后出现的选择器优先级更高，!important也适用

一句话总结： !important > 行内样式 > ID 选择器 > (类选择器 | 属性选择器 | 伪类选择器 ) > 元素选择器 > * > 继承

---

<span id="jump4"></span>

## CSS 选择符有哪些？

- id选择器（#myid）

- 类选择器（.myclassname）

- 标签选择器（div,h1,p）

- 后代选择器（h1 p）

- 相邻后代选择器（子）选择器（ul>li）

- 兄弟选择器（li~a）

- 相邻兄弟选择器（li+a）

- 属性选择器（```a[rel="external"]```）

- 伪类选择器（a:hover,li:nth-child）

- 伪元素选择器（::before、::after）

- 通配符选择器（*）

---

<span id="jump5"></span>

## 浏览器是怎样解析 CSS 选择器的

采用从右至左的方式读取CSS规则

### 从左至右

如果正向解析，如果采用从左至右的方式读取 CSS 规则，那么大多数规则读到最后（最右）才会发现是不匹配的，这样会做费时耗能，最后有很多都是无用的，我们花费了大量的时间在回溯匹配不符合规则的节点

例如「div div p em」，我们首先就要检查当前元素到 html 的整条路径，找到最上层的 div，再往下找，如果遇到不匹配就必须回到最上层那个 div，往下再去匹配选择器中的第一个 div

### 从右至左

如果采取从右向左的方式，那么只要发现最右边选择器不匹配，就可以直接舍弃了，避免了许多无效匹配

在 DOM 树中一个元素可能有若干子元素，如果每一个都去判断一下显然性能太差；而一个子元素只有一个父元素，所以找起来非常方便

